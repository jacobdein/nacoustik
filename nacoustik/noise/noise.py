"""
Noise processing

Jacob Dein 2016
nacoustik
Author: Jacob Dein
License: MIT
"""


import numpy as np
import pandas as pd
from numba import guvectorize, float64, int64
from scipy.ndimage import label, find_objects
from scipy.ndimage.morphology import generate_binary_structure


# implemented as a universal function via numba.guvectorize
@guvectorize([(float64[:,:,:], int64[:], int64[:], 
			   float64[:,:,:], float64[:,:,:])], 
			 '(c,f,t),(h),(e)->(c,f,h),(c,f,e)', nopython=True)
def _calculate_histograms(a, h_bins, e_bins, hists, edges):
	for channel in range(a.shape[0]):
		for f_band in range(a.shape[1]):
			hists[channel, f_band], edges[channel, f_band] = \
				np.histogram(a[channel, f_band], h_bins[0])


def _find_cutoff_index(histogram, cutoff_count):
	cumsum = 0.0
	for index, value in histogram.iteritems():
		cumsum += value
		if cumsum >= cutoff_count:
			break
	return index


# implemented as a universal function via numba.guvectorize
@guvectorize([(float64[:,:,:], float64[:,:,:])], 
			 '(c,f,t)->(c,f,t)', nopython=True)
def _denoise(a, b):
	for channel in range(2):
		for f_band in range(4, a.shape[1] - 4):
			for t_step in range(1, a.shape[2] - 1):
				neighborhood = a[channel, \
								 f_band - 4:f_band + 5, \
								 t_step - 1:t_step + 2]
				if neighborhood.mean() < 10:
					b[channel, f_band, t_step] = neighborhood.min()
				else:
					b[channel, f_band, t_step] = neighborhood[4, 1]


def remove_background_noise(a, N=0.1, iterations=1):
	"""
	Removes background noise
	
	Parameters
	----------
	a: numpy float64 array
		a 3d array (channels, frequency bands, time steps)
		representing the spectrogram of a wave signal
	
	N: float, default = 0.1
		decimal value (0 - 1) to determine signal cutoff levels 
	
	iterations: int, default = 1
		number of iterations to run the denoise algorithm
	"""
	
	# determine number of histogram bins
	n_bins = np.round(a.shape[1] / 8).astype(np.int)
		
	# allocate arrays for histograms and edge values
	shape_histograms = (a.shape[0], a.shape[1], n_bins)
	shape_edges = (a.shape[0], a.shape[1], n_bins + 1)
	histograms = np.empty(shape_histograms)
	edges = np.empty(shape_edges)
	
	# call 'calculate_histograms' ufunc
	histograms, edges = _calculate_histograms(a, 
		 # number of bins in histograms, as an array (hack)
		 # necessary for numba.guvectorize function
		 np.ones(shape=(n_bins), dtype=np.int64) * n_bins, 
		 # number of histogram edges, as an array (hack)
		 np.ones(shape=(n_bins + 1), dtype=np.int64) * (n_bins + 1), 
		 histograms, edges)
	
	# allocate array for cutoff values
	cutoffs = np.empty(shape=(histograms.shape[0], histograms.shape[1]))
	# loop through all histograms for each frequency band
	for channel in range(a.shape[0]):
		for f_band in range(a.shape[1]):
			# convert histogram to pandas.Series 
			# (to use moving average function)
			histogram = pd.Series(histograms[channel, f_band])
			# smooth
			histogram = histogram.rolling(center=False, window=5).mean()
			# replace NaN values generated by moving average
			histogram.replace(np.NaN, 0, inplace=True)
			# determine cutoff values
			cutoff_count = histogram[0:histogram.idxmax()].sum() * 0.68 * N
			cutoffs[channel, f_band] = edges[channel, f_band, 
				_find_cutoff_index(histogram, cutoff_count)]

	#cutoffs_smooth = np.empty(shape=cutoffs.shape)
	for channel in range(a.shape[0]):
		smoothed = pd.Series(cutoffs[channel]) \
					.rolling(center=False, window=5).mean()
		# replace NaN values
		smoothed.replace(np.NaN, smoothed.max(), inplace=True)
		cutoffs[channel] = smoothed.values

	ale = np.empty_like(a)
	it = np.nditer([cutoffs], flags=['c_index', 'multi_index'], 
				   op_flags=[['readonly']])
	while not it.finished:
		ale[it.multi_index[0], it.multi_index[1]] = \
			a[it.multi_index[0], it.multi_index[1]] - it.value
		it.iternext()

	ale = np.select(condlist=[ale > 0], choicelist=[ale], default=0)

	for i in range(iterations):
		ale = _denoise(ale, np.zeros_like(ale))
	
	return ale


def _label(ale):
	s = generate_binary_structure(2, 2)
	labels = np.empty_like(ale, dtype=np.int32)
	n_features = np.empty(shape=(2), dtype=np.int32)
	for channel in range(2):
		labels[channel], n_features[channel] = label(ale[channel])#, structure=s)
	return labels, n_features

def _find_low_rois(cutoff_frequency, rois, n_channels, freq_delta):
	cutoffs = []
	for channel in range(n_channels):
		index = np.ceil(cutoff_frequency / freq_delta).astype(np.int32)
		cutoffs.append(np.searchsorted(rois[channel][:, 0], index))
	return cutoffs

def _find_high_rois(cutoff_frequency, rois, n_channels, freq_delta):
	indices = []
	for channel in range(n_channels):
		index = np.ceil(cutoff_frequency / freq_delta).astype(np.int32)
		indices.append(np.where(rois[channel][:, 1] >= index)[0])
	return indices


def remove_anthrophony(ale, time_delta, freq_delta, cutoffs=(1000, 11000)):
	"""
	Removes anthrophony from a PSD spectrogram
	
	Parameters
	----------
	ale: numpy float64 array
		a 3d array (channels, frequency bands, time steps)
		representing the spectrogram of a wave signal (with ale applied)
	
	time_delta: float
		amount of time between spectrogram intervals
	
	freq_delta: float
		width of each spectrogram frequency band
		
	cutoffs: tuple of integers, (low_cutoff, high_cutoff), default = (1000, 11000)
		low and high cutoff frequencies that 
		determine what noise events to remove
		(any event with frequencies above and below the range)
	"""
	
	# label
	s = generate_binary_structure(2, 2)
	labels = np.empty_like(ale, dtype=np.int32)
	n_features = np.empty(shape=(2), dtype=np.int32)
	for channel in range(labels.shape[0]):
		labels[channel], n_features[channel] = label(ale[channel])#, structure=s)
	
	roi_windows = []
	for channel in range(labels.shape[0]):
		roi_windows_channel = find_objects(labels[channel])
		roi_windows.append(roi_windows_channel)
	
	rois = []
	for channel in range(labels.shape[0]):
		rois_channel = np.empty(shape=(n_features[channel], 4), dtype=np.int32)
		index = 0
		for window in roi_windows[channel]:
			# frequency band
			rois_channel[index, 0] = window[0].start
			rois_channel[index, 1] = window[0].stop
			# time window
			rois_channel[index, 2] = window[1].start
			rois_channel[index, 3] = window[1].stop
			index += 1
		rois.append(rois_channel)
	
	#low_cutoffs
	low_cutoffs = []
	for channel in range(labels.shape[0]):
		index = np.ceil(cutoffs[0] / freq_delta).astype(np.int32)
		low_cutoffs.append(np.searchsorted(rois[channel][:, 0], index))

	#high_indices
	high_indices = []
	for channel in range(labels.shape[0]):
		index = np.ceil(cutoffs[1] / freq_delta).astype(np.int32)
		high_indices.append(np.where(rois[channel][:, 1] >= index)[0])
	  
	for channel in range(labels.shape[0]):
		for i in range(0, low_cutoffs[channel]):
			a_roi = labels[channel, rois[channel][i, 0]:rois[channel][i, 1], rois[channel][i, 2]:rois[channel][i, 3]]
			mask = np.ma.masked_not_equal(a_roi, value=(i + 1)).mask
			a_roi = ale[channel, rois[channel][i, 0]:rois[channel][i, 1], rois[channel][i, 2]:rois[channel][i, 3]] * mask
			ale[channel, rois[channel][i, 0]:rois[channel][i, 1], rois[channel][i, 2]:rois[channel][i, 3]] = a_roi
	
	for channel in range(labels.shape[0]):
		for i in high_indices[channel]:
			a_roi = labels[channel, rois[channel][i, 0]:rois[channel][i, 1], rois[channel][i, 2]:rois[channel][i, 3]]
			mask = np.ma.masked_not_equal(a_roi, value=(i + 1)).mask
			a_roi = ale[channel, rois[channel][i, 0]:rois[channel][i, 1], rois[channel][i, 2]:rois[channel][i, 3]] * mask
			ale[channel, rois[channel][i, 0]:rois[channel][i, 1], rois[channel][i, 2]:rois[channel][i, 3]] = a_roi
	
	return ale