"""
Noise processing

Jacob Dein 2016
nacoustik
Author: Jacob Dein
License: MIT
"""


import numpy as np
import pandas as pd
from numba import guvectorize, float64, int64


# implemented as a universal function (ufunc) via numba.guvectorize
@guvectorize([(float64[:,:,:], int64[:], int64[:], 
               float64[:,:,:], float64[:,:,:])], 
             '(c,f,t),(h),(e)->(c,f,h),(c,f,e)', nopython=True)
def _calculate_histograms(a, h_bins, e_bins, hists, edges):
    for channel in range(a.shape[0]):
        for f_band in range(a.shape[1]):
            hists[channel, f_band], edges[channel, f_band] = \
                np.histogram(a[channel, f_band], h_bins[0])


def _find_cutoff_index(histogram, cutoff_count):
    cumsum = 0.0
    for index, value in histogram.iteritems():
        cumsum += value
        if cumsum >= cutoff_count:
            break
    return index


# implemented as a universal function (ufunc) via numba.guvectorize
@guvectorize([(float64[:,:,:], float64[:,:,:])], 
             '(c,f,t)->(c,f,t)', nopython=True)
def _denoise(a, b):
    for channel in range(2):
        for f_band in range(4, a.shape[1] - 4):
            for t_step in range(1, a.shape[2] - 1):
                neighborhood = a[channel, \
                                 f_band - 4:f_band + 5, \
                                 t_step - 1:t_step + 2]
                if neighborhood.mean() < 10:
                    b[channel, f_band, t_step] = neighborhood.min()
                else:
                    b[channel, f_band, t_step] = neighborhood[4, 1]


def remove_background_noise(a, N=0.1, iterations=1):
    """
    Removes background noise
    
    Parameters
    ----------
    a: numpy float64 array
        a 3d array (channels, frequency bands, time steps)
        representing the spectrogram of a wave signal
    
    N: float, default = 0.1
        decimal value (0 - 1) to determine signal cutoff levels 
    
    iterations: int, default = 1
        number of iterations to run the denoise algorithm
    """
    
    # determine number of histogram bins
    n_bins = np.round(a.shape[1] / 8).astype(np.int)
        
    # allocate arrays for histograms and edge values
    shape_histograms = (a.shape[0], a.shape[1], n_bins)
    shape_edges = (a.shape[0], a.shape[1], n_bins + 1)
    histograms = np.empty(shape_histograms)
    edges = np.empty(shape_edges)
    
    # call 'calculate_histograms' ufunc
    histograms, edges = _calculate_histograms(a, 
         # number of bins in histograms, as an array (hack)
         # necessary for numba.guvectorize function
         np.ones(shape=(n_bins), dtype=np.int64) * n_bins, 
         # number of histogram edges, as an array (hack)
         np.ones(shape=(n_bins + 1), dtype=np.int64) * (n_bins + 1), 
         histograms, edges)
    
    # allocate array for cutoff values
    cutoffs = np.empty(shape=(histograms.shape[0], histograms.shape[1]))
    # loop through all histograms for each frequency band
    for channel in range(a.shape[0]):
        for f_band in range(a.shape[1]):
            # convert histogram to pandas.Series 
            # (to use moving average function)
            histogram = pd.Series(histograms[channel, f_band])
            # smooth
            histogram = histogram.rolling(center=False, window=5).mean()
            # replace NaN values generated by moving average
            histogram.replace(np.NaN, 0, inplace=True)
            # determine
            cutoff_count = histogram[0:histogram.idxmax()].sum() * 0.68 * N
            cutoffs[channel, f_band] = edges[channel, f_band, 
                _find_cutoff_index(histogram, cutoff_count)]

    #cutoffs_smooth = np.empty(shape=cutoffs.shape)
    for channel in range(a.shape[0]):
        smoothed = pd.Series(cutoffs[channel]) \
                    .rolling(center=False, window=5).mean()
        # replace NaN values
        smoothed.replace(np.NaN, smoothed.max(), inplace=True)
        cutoffs[channel] = smoothed.values

    ale = np.empty_like(a)
    it = np.nditer([cutoffs], flags=['c_index', 'multi_index'], 
                   op_flags=[['readonly']])
    while not it.finished:
        ale[it.multi_index[0], it.multi_index[1]] = \
            a[it.multi_index[0], it.multi_index[1]] - it.value
        it.iternext()

    ale = np.select(condlist=[ale > 0], choicelist=[ale], default=0)

    for i in range(iterations):
        ale = _denoise(ale, np.zeros_like(ale))
    
    return ale